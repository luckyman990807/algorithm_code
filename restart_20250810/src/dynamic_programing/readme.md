# 动态规划
## 四种模型
### 1、从左向右尝试模型（例题：背包，贴纸拼单词）
### 2、范围尝试模型（例题：两玩家只能从最左或最右抽纸牌问题）
### 3、样本对应模型（一个样本做行，一个样本做列）（例题：最长公共子序列）
#### 往往讨论的是当前的结尾该如何组织可能性。
为什么？ 因为只要结尾位置分清楚了，剩下的都是算过的，或者说可以递归的

如何讨论可能性？比方两个样本的结尾位置分别为i和j，可能性就是围绕要不要i，要不要j展开，正着反着都行：

思路一：

可能性1:同时考虑i和j，可能性2:一定不考虑i，可能性3:一定不考虑j。（2和3重合的部分是：同时不考虑i和j）

思路二：

可能性1:同时不考虑i和j，可能性2:一定考虑i，可能性3:一定考虑j。（2和3重合的部分是：同时考虑i和j）

思路三：

可能性1:同时考虑i和j，可能性2:考虑i不考虑j，可能性3:不考虑i考虑j，可能性4：既不考虑i也不考虑j。

### 4、业务限制模型

## 优化
### 1、空间优化
#### 用一个一维数组滚动赋值的方式代替赋值一个二维表格，以节省空间。这个一维数组可以是二维数组中的一行，也可以是一列，如果二维数组行多列少，就取一行，最省空间，反之就取一列最省空间。
场景1、一个格子依赖左边和上边的格子：

一维数组从左往右赋值即可，左边就是原来的左边，更新前的自己就是原来的上边

左上角怎么得到：肯定是base case可以直接得到，因为左上角即没有左也没有上；

第一行怎么得到：从左往右赋值，肯定只依赖左，以为第一行没有上；

第一列怎么得到：只依赖上，也就是更新前的自己；

普通行怎么赋值：从左往右赋值，依赖左和上，左边就是原来的左边，更新前的自己就是原来的上边。

场景2、一个格子依赖上边和左上： 

一维数组从右往左赋值即可，更新前的自己就是原来的上，更新前的左边就是原来的左上。

第一行怎么得到：肯定是base case可以直接得到，因为第一行既没有上也没有左上；

第一列怎么得到：只依赖上，也就是更新前的自己；

普通行怎么赋值：从右往左赋值，更新前的自己就是原来的上，更新前的左边就是原来的左上。

场景3、一个格子依赖左，上，左上：

一维数组从左往右赋值+2个临时变量。

左上角：base case；

第一行：只依赖左；

第一列：只依赖上；

普通行：左边位置更新前，用变量a记录下更新前的值，作为当前位置的左上；当前位置有了左上，有了上（更新前的自己），有了左，就能求出更新后的值，用变量b存起来，然后a记录当前位置更新前的值，然后把b更新到当前位置。








