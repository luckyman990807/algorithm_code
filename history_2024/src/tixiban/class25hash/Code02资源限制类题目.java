package tixiban.class25hash;

public class Code02资源限制类题目 {
    /**
     * 资源限制技巧汇总
     * 1.布隆过滤器用于集合的建立与查询，并可以节省大量空间（已讲）
     * 2.一致性哈希解决数据服务器的负载管理问题（已讲）
     * 3.利用并查集结构做岛问题的并行计算（已讲）
     * 4.哈希函数可以把数据按照种类均匀分流
     * 5.位图解决某一范围上数宇的出现情况，并可以节省大量空间
     * 6.利用分段统计思想、并进一步节省大量空间
     * 7.利用堆、外排序来做多个处理单元的结果合并
     */

    /**
     * 利用哈希函数把数据按种类均匀分流
     *
     * 题目1:
     * 32位无符号整数的范围是0~4,294,967,295(42亿),
     * 现在有一个正好包含40亿个无符号整数的文件,可以使用最多1GB的内存,怎么找出出现次数最多的数?
     *
     * 40亿个数最坏情况是40亿种不同的数,这种情况下不论是排序后遍历找出现最多的,还是直接用哈希表存,都无法用1GB搞定.
     *
     * 思路:
     * 32位无符号整数是4字节,哈希表一条记录key:value(某种数的值:出现的个数)是8字节,1GB能存大约125,000,000条记录(1亿两千五百万)
     * 保守一点去尾法=1亿,更保守一点除以10=1千万
     * 我们就假设1GB的空间可以存1千万条数据,超出一点也可以(因为我们直接除以10了,非常保守了)
     * 那么准备40亿/1千万=400个文件,40亿个数分别计算哈希模400存入对应的文件,文件中以哈希表的格式存,即 某种数的值:出现的个数.
     * 这样每个文件最差情况也只有1千万条数据,也就是1千万种数,即便超过1千万,也不会超过太多(哈希函数均匀性决定的).
     * 然后依次读取每个文件,计算每个文件中出现次数最多的数,然后所有文件中的max再求一次max,得到答案.
     *
     * 注意:
     * 哈希函数的性质,相同输入一定导致相同输出,所以不同种数可能会碰撞进入同一文件,但是同一种数一定不可能出现在不同文件.所以计算出现次数不会出错.
     *
     *
     * 题目2:
     * 有一个包含100亿个URL的大文件,假设每个URL占用64B,请找出所有重复的URL.
     * 思路:
     * 如果允许有一个比较小的失误率,可以用布隆过滤器,遍历所有URL,如果没有在过滤器中描黑,就描黑,如果过描黑了,就记录重复.
     * 如果不允许有失误率,那就用哈希.
     * 把大文件通过一个哈希函数分流成多个小文件,然后在每个小文件里计算重复(不管是排序还是哈希表).
     * 如果小文件还是太大,就用另一个哈希函数把每个小文件再分流成小小文件,然后再每个小小文件里计算重复.
     * 因为不管用哪个哈希函数计算,重复的url永远会被分到同一个文件里(哈希函数的性质,输入相同一定导致输出相同)
     */

    /**
     * 利用位图解决某一范围上数字的出现情况,并节省大量空间
     *
     * 题目:
     * 32位无符号整数的范围是0~4,294,967,295(42亿),
     * 现在有一个正好包含40亿个无符号整数的文件,所以在整个范围内必然有没出现过的数.
     * 可以使用最多1GB的内存,怎么找到所有没出现过的数?
     *
     * 位图:用二进制的一位表示某个元素的出现情况.
     *
     * 思路:
     * 32位无符号整数的范围一共有4,294,967,296个数(42亿),就需要4,294,967,296个比特位,
     * 而1GB最多可以表示8,000,000,000个比特位,差不多是所需要的2倍,因此空间足够支持.
     * 怎么把1GB空间变成比特位的位图?
     * 申请一个长度为4,294,967,296/8/4=132,217,728长度的int数组,数组的每个元素是int,有32字节,
     * 那么整个数组就是一个位图,arr[0]表示位图的0~31位,arr[1]表示位图的32~63位...
     * 怎么确定一个整数在位图上的位置?
     * 整数/32算出在数组下标,整数%32算出在数组元素的第几位.例如,整数34在arr[1]的第2位(从0开始)
     * 把40亿个整数收进位图:
     * 遍历每个整数,按照上面的方法找到位图上的比特位,并描黑,arr[value / 32] |= 1 << (value % 32)
     * 检查一个数有没有出现过:
     * 如果计算出位图上的比特位是1,说明出现过,否则说明没出现过,isExists = arr[value / 32] & (1 << (value % 32)) == 1 ? 1 : 0
     * 例如检查整数34有没有出现过,arr[2]与上1左移2位,如果没出现过,那么arr[2]第2位就是0,与完的结果就是0,如果出现过,那么arr[2]第2位就是1,与完的结果就是1.
     *
     * 总结:申请整形数组构建位图,把所有40亿个数收进位图,位图上没描黑的位置对应的整数就是没出现过的.
     *
     */

    /**
     * 利用分段统计思想，并进一步节省大量空间
     *
     * 题目1：
     * 32位无符号整数的范围是0~4,294,967,295(42亿),
     * 现在有一个正好包含40亿个无符号整数的文件,所以在整个范围内必然有没出现过的数.
     * 可以使用最多3KB的内存,怎么找出任意一个没出现过的数?
     *
     * 比上一道题目有更苛刻的空间限制，但是只要求找一个没出现的数。
     *
     * 思路：
     * 3KB假设全部用来维持无符号整数数组，那么数组长度最多3K/4=750，我们取长度为750以下最接近的2的某次方512，把整个范围分成512份，每份的长度是2^23=8388608
     * arr[0]用来统计0~8388607上的数出现的词频，arr[1]用来统计8388608~16777215上的数出现的词频...(怎么统计范围上的词频?arr[x/8388608]++,x是读到的数字)
     * 因为整个范围上有43亿个数，文件只有40亿个数，所以一定有某一份不满8388608个数，找到这个不满的小范围，把他分成512份，再按照同样的方式找到不满的小小范围...
     * 就这样每次分512份，最后总能找到一个没出现的数。
     *
     * 为什么要找2的某次方?为了能把整个范围均分.
     *
     *
     * 进阶题目2：3KB内存的限制改成只能使用有限几个变量
     *
     * 思路：
     * 3KB空间的时候用512分，有限几个变量的时候可以用二分，只记录left左边界，right右边界，mid中点。
     *
     *
     * 题目3:
     * 32位无符号整数的范围是0~4,294,967,295(42亿),
     * 现在有40亿个无符号整数,可以最多使用3KB的内存,怎么找到这40亿个数的中位数?
     *
     * 思路:
     * 依然取最接近内存长度的2的某次方512,申请一个arr=int[512],把整个范围分成512份,
     * arr[0]记录0~2^32-1范围上出现了几个数,arr[1]记录2^32 ~ 2*2^32-1范围上出现了几个数,arr[2]记录2*2^32 ~ 3*2^32-1范围上出现了几个数...
     * 中位数就是所有整数排序后第20亿个数,假如arr[100]的前缀和=18亿,arr[101]的前缀和=24亿,那么中位数就是arr[101]对应范围上排序后的第2亿个数.
     * 拿arr[101]范围的数分成512份进行一样的计算,总能找到中位数.
     *
     */

    /**
     * 分段+位图
     *
     * 题目:
     * 32位无符号数的范围是0~4,294,967,295(42亿),
     * 现在有40亿个无符号整数,可以使用最多1GB内存,找出所有出现了两次的数.
     *
     * 思路:
     * 出现两次,就用位图两位表示一个数的次数,00表示0次,01表示1次,10表示2次,11表示3次及以上.
     * 整个范围的长度是4,294,967,296(42亿),位图上每个数的次数用2位表示,需要用42亿*2=84亿个比特位,
     * 而1GB最多有1,000,000,000 * 8 = 80亿个比特位,不够用,怎么办?分段,
     * 统计整个范围的前半段,也就是前2^31范围,只需要42亿个比特位,可以从1GB里拿出42亿个比特位构建位图,即42亿/8/4=132,217,728长度的int数组,
     * arr[0]记录0~15范围的整数的位图,arr[1]记录16~31范围的整数的位图...
     * 第一次,遍历所有40亿个整数,如果位于后2^31范围,忽略,如果位于前2^31范围,先/16算出数组下标,再%16*2、%16*2+1算出计数的两个比特位,更新次数(不等于11则+1,等于11则不变).
     * 第二次,位于前2^31范围的忽略,位于后2^31范围的计算.先减2^31再/16算出数组下标,再%16*2、%16*2+1算出给这个整数计数的两个比特位,更新次数.
     *
     */

    /**
     * 利用堆排序做多个处理单元的结果合并
     *
     * 题目1:
     * 32位无符号数的范围是0~4,294,967,295(42亿),
     * 有一个10GB大小的文件,每一行都装着一个无符号整数,整个文件是无序的,给你5GB的内存空间,请你输出一个10GB大小的文件,就是原文件排好序的结果.
     *
     * 思路:
     * 5GB折合int数组大约1,250,000,000(12亿)长度,保守一点申请一个1万长度的大根堆,堆里存的元素是{整数,出现的个数}
     * 遍历整个文件,如果堆不满,直接插入;如果堆满了,当前整数在堆中出现过,直接更新个数;如果没出现过,跟堆中最大的比较,如果当前整数比最大的小,替换.
     * 遍历完一遍之后,整个文件中最小的1万种数已经在堆中了,假如{1,1000},{3,500},{5,700},那么向结果文件中写入1000个1,500个3,700个5,
     * 记录当前堆中最大值cur=5,再次遍历文件,小于等于cur的直接跳过,大于cur的按照同样的方法组建大根堆,然后接着文件指针的地方继续写...
     *
     * 外排序就是不用堆,每次遍历来找最大值、找是否存在.
     *
     *
     * 题目2:
     * 给定一个包含40亿个无符号整数的大文件，找出出现次数最多的top100
     * 思路:
     * 哈希函数分流+堆上堆.
     * 一个哈希函数分流成多个小文件，每个小文件找出top100，每个小文件的top100形成大根堆。
     * 所有小文件的堆顶元素,形成一个总的大根堆.总堆弹出堆顶元素,确认来自哪个小文件,小文件也弹出堆顶,重新成堆,然后把小文件新的堆顶插入总堆，重新成堆。
     * 直到总堆弹出100个。
     * 一次哈希分流的小文件还是很大的话，就再来一次哈希分流出小小文件。
     *
     * 如果不用堆,用外排序,就是每次遍历找最大值.
     */

    /**
     * 资源限制类题目的限制、限定一定要跟面试官argue得到,要不然限定不全没法做.
     * 面试官一上来就会说的模棱两可,等着你问.
     */
}
