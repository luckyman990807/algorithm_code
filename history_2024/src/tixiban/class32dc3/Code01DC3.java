package tixiban.class32dc3;

/**
 * 前置知识
 *
 * 1.后缀字符串
 * 字符串abcd, 从第0位开始的后缀是第0位到最后一位,也就是abcd, 从第3位开始的后缀是d
 *
 * 2.后缀排名数组
 * 一个字符串的所有后缀字符串,按照字典序从低到高排名,然后把对应的开头下标存到数组中.arr[i]=k表示排第i名的是从第k位开始的后缀字符串
 *
 * 3.字典序
 * 相同长度的字符串比较字典序,就相当于把字符串看作一个很大进制的数字,每一位是ascii码,从高位到低位依次比较ascii码,直到有一位分出大小.
 * 不同长度的字符串,给较短字符串后面补ascii码的最小值0,然后按照相同长度的字符串比较.
 *
 * 问:会不会有排名相同的后缀字符串?
 * 答:不可能,因为每个后缀的长度不同,长度不同字典序必然不同
 *
 * 问:给定一个字符串,生成后缀排名数组,用暴力方法的复杂度是多少?
 * 答:O(N^2 * logN)
 * 首先,给定一个字符串,生成全部的后缀字符串数组,代价是O(N^2),后缀数组长度为N
 * 其次,排序算法总体调度的代价是O(N*logN),而每个字符串元素的比较代价是O(N),因此后缀字符串数组排序的代价是O(N^2 * logN)
 * 综上,给定一个字符串,生成后缀排名数组,用暴力方法的复杂度是O(N^2 * logN)
 *
 * DC3生成后缀排名数组的复杂度是O(N).
 * 3指的是这个算法用到类似3维基数排序.
 *
 * 4.三维基数排序的复杂度
 * 给定N个样本,每个样本有3个维度,例如要求对N个样本排序,规则是第一维权重最高,第一维相等的情况下比较第二维,第二位相等比较第三维.
 * 假设样本为:[(12,500,8435), (345,54,8), (543,564,123), (9,13,3543), (4326,3,153)]
 * 思路:所有维度中的最大值是8435,就准备8435个桶.首先所有样本按照第三维遍历,样本0的第三维=8435,就放到8435号桶,样本1第三维=8,就放到8号桶……
 * 放完之后遍历所有桶把样本取出,取出的顺序就是[(345,54,8), (543,564,123), (4326,3,153), (9,13,3543), (12,500,8435)],
 * 然后再遍历第二维依次入桶,再遍历所有桶取出,再遍历第一维依次入桶,再遍历所有桶取出,得到的结果就是排好序的了.
 * 第一维最后排序,所以第一维的权重最高,会直接影响到最终的顺序.第一维相同时,会保留第二维的次序,同理第二维相同时,会保留第三维的次序.
 * 复杂度:每个样本都进出桶3次,因此复杂度为O(N).
 *
 * 得到前置结论:三维基数排序复杂度为O(N)
 *
 * 5.扩展:字符串可以求后缀排名数组,数组也可以求后缀排名数组,因为字符串就相当于是字符的数组,现在把自负换成整数或者其他类型,也是一样的道理.
 *
 * 6.对字符串的后缀数组元素分类
 * 按照后缀开头下标模3的结果分为0类、1类、2类,记为S0,S1,S2. S12表示1类和2类的并集.
 *
 * 7.假设S12已经按字典序排好,如何以O(N)的复杂度给S0排好序? 上面讲了暴力方法是O(N^2 * logN)
 * 答:假设字符串aababaa,后缀字符串数组=[aababaa, ababaa, babaa, abaa, baa, aa, a], S12=[ababaa, babaa, baa, aa]
 * 排好序的S12=[aa, ababaa, baa, babaa]
 * 而S0=[aababaa, abaa, a], 根据S12的排名转换成二维样本=[(a,S12中第1名), (a,S12中第2名), (a,最小ascii码)],用二维基数排序,O(N)可得结果.
 *
 * 8.假设S12和S0都已经按字典序排好,如何以O(N)的代价把S012(也就是整个后缀数组)排好?
 * 答:体系班.class1_13.merge.
 * 定义两个指针分别指向已经排好序的S0和S12,哪边指针指的小就把哪边的纳入结果中,同时该指针++.直到其中一个指针走完,就把另一个指针剩下的都纳入结果.
 * 那么S0中一个字符串和S12中一个字符串怎么比较大小呢?
 * 答:S0和S1相遇,最多比2次.S0和S2相遇,最多比3次.
 * 情况1.S0和S1相遇,例如abaa和baa,根据S12中的排名转换成二维样本,即(a,S12中第2名)和(b,S12中第0名),如果第一维不想等就可以直接分出大小,如果第一维相等就比较后面整体转换成的第二维.
 * 情况2.S0和S2相遇,例如aababaa和babaa,根据S12中的排名转换成三维样本,即(a,a,S12中第3名)和(b,a,S12中第2名).如果第一维不想等就直接分出大小,否则就比第二维、第三维.
 * 复杂度:每个样本要么进出桶2次要么3次,所以复杂度为O(N).
 *
 * 得到前置结论:假设S12类已经按字典序排好,那么只需O(N)就可以将整个后缀数组排序.
 *
 * 综上,得到了2个前置结论:
 * 1.三维基数排序复杂度为O(N)
 * 2.如果S12已经有序,那么只需O(N)就能让整个后缀数组有序
 */

/**
 * DC3
 * 问题的关键来到了如何让S12有序? 我们不妨让S12中的字符串只取前3位(不够3位的补最小ascii码)
 *
 * 1.第1种情况,在只有3位的情况下S12中没有重复值,那么可以通过三维基数排序解决,每个样本就是一个长为3的字符串,每个维度就是一个字符,复杂度O(N)
 *
 * 2.第2种情况,只有3位的情况下有重复值,那么没法通过三维基数排序解决.
 * 例如字符串mississippi,
 * S12 =   [iss,ssi,iss,ssi,ipp,ppi,i00],有重复的值,
 * 开头下标为 1   2   4   5   7   8   10
 * 排名为    3   5   3   5   2   4   1   (这里假设从1开始)
 * 这样怎么给S12排序?
 * 可以把S12每个元素的名次生成一个新数组,左边是S1的名次,右边是S2的名次:
 * 新数组为       [3,3,2,1,0,5,5,4]  (注意这里的0指最小ascii码)
 * 下标           0,1,2,3,4,5,6,7
 * 对应的开头下标为 1,4,7,10, 2,5,8
 * 把这个新数组递归生成后缀排名数组,那么新数组0下标后缀的排名就是S12中1下标后缀的排名,新数组1下标后缀的排名就是S12中4下标后缀的排名...
 *
 * 为什么?
 *
 * 为什么新数组递归生成后缀排名数组就能映射S12的排名?
 * 首先要知道为什么S12中1下标开头的后缀和4下标开头的后缀分不出排名?是因为下标123的子串和下标456的子串的三位完全相同,比不出大小.
 * 如果想比大小,就要借助后面几位继续比较.而123子串(即1下标开头的3位后缀串)的下一位是4下标,看新数组4下标开头的子串的排名正贴在1下标开头的子串的后面,
 * 也就是说1下标后缀名次3和4下标后缀名次3分不出大小,就把二者分别后3位抽象成排名继续参与比较,也就是变成33和32比,就能分出大小了.
 * 而这就是DC3的第一种情况,可以通过最多三维基数排序解决.
 *
 * 为什么S1和S2之间要加个最小ascii码隔开?
 * 假如新数组中为[3,2,1,1,0,5,5,4],1排名也是重复的,
 * 如果不加0隔开,[3,2,1,1,5,5,4],
 * 那么递归求新数组的后缀排名数组时,原本老数组中最后一个1后面没有别的值了,他的字典序应该比前一个1小,但是实际后一个1后面却跟了个5,变成11和15比,反而是前面的1更小.
 * 因此要加最小ascii码隔开,防止S2的值影响S1的比较
 *
 * 问:如果排名一样的两个分别在S1和S2中,这个递归求后缀排名数组的方法还有效吗?
 * 答:有效,因为不管相同排名的两个属于哪个分类,只要按照S1在一起S2在一起的方式摆,那么他需要的后面的排名就必然贴在他后面.
 *
 * 综上,DC3生成后缀排名数组的复杂度:
 * 情况1:后缀只取3位的情况下S12无重复值,只需要一次三维基数排序
 * T(N)=O(N)
 * 情况2:后缀只取3位的情况下S12有重复值,需要把S12递归生成后缀排名数组,再把S0排序,再merge
 * T(N)=T(2N/3)+O(N)+O(N),最终T(N)=O(N)
 *
 */

/**
 * DC3注意事项
 *
 * 1.DC3默认支持求整型数组的后缀排名数组,如果题目给的是字符串,可以转成ascii码数组.
 *
 * 2.DC3要求输入的整型数组最小值不小于1,因为计算过程中会插入最小ascii码0.如果不满足,要处理成满足的(每个值都加 min+1).
 *
 * 3.如果输入的整型数组min=50,max=100,那么可以都减49变成min=1,max=51,这样即满足条件,有能让桶尽量少,节约空间
 *
 *
 *
 */
public class Code01DC3 {
    public static class DC3 {

        // sa[i]=k表示按照字典序排第i名的是k开头的子串,都从0开始.下标表示排名
        public int[] sa;

        // rank[i]=k表示i开头的子串按照字典序排第k名,都从0开始.下标表示当前子串的开头下标
        public int[] rank;

        // h[i]=k表示i开头的子串跟前一名的最长公共前缀长为k (i开头的子串按字典序排x名,找到x-1名,是j开头的子串,这俩子串的最长公共前缀长度为k)
        // height[i]=k表示第i名的子串跟前一名的最长公共前缀长度为k
        public int[] height;

        // 构造方法的约定:
        // 数组叫nums，如果你是字符串，请转成整型数组nums
        // 数组中，最小值>=1
        // 如果不满足，处理成满足的，也不会影响使用
        // max, nums里面最大值是多少
        public DC3(int[] nums, int max) {
            sa = sa(nums, max);
            rank = rank();
            height = height(nums);
        }


        /**
         * 生成sa数组,也就是后缀排名数组
         * @param nums
         * @param max
         * @return
         */
        private int[] sa(int[] nums, int max) {
            int n = nums.length;
            int[] arr = new int[n + 3];
            for (int i = 0; i < n; i++) {
                arr[i] = nums[i];
            }
            return skew(arr, n, max);
        }


        /**
         * 生成后缀排名数组具体过程
         * @param nums
         * @param n
         * @param K
         * @return
         */
        private int[] skew(int[] nums, int n, int K) {
            /**
             * S12里放的是1类和2类后缀的开头下标,即[1,2,4,5,7,8,...]
             */
            int n0 = (n + 2) / 3, n1 = (n + 1) / 3, n2 = n / 3, n02 = n0 + n2;
            int[] s12 = new int[n02 + 3], sa12 = new int[n02 + 3];
            for (int i = 0, j = 0; i < n + (n0 - n1); i++) {
                if (0 != i % 3) {
                    s12[j++] = i;
                }
            }
            /**
             * 三维基数排序,第一次对s12在第三维上排序,生成后缀排名数组保存在sa12,第二次基于上次的结果在第二维上排序,生成后缀排名数组保存在s12,第三次再基于上次的结果在第一维上排序,生成后缀排名数组保存在sa12
             */
            radixPass(nums, s12, 2, sa12, n02, K);
            radixPass(nums, sa12, 1, s12, n02, K);
            radixPass(nums, s12, 0, sa12, n02, K);


            /**
             * 检查三维基数排序是否把S12严格排好序.
             * 并且把S12中的1类和2类的名次分开,1类的名次在左边,2类的名次在右边.名次从1开始,并且只是S12内部的名次
             */
            // c0,c1,c2是后缀字符串三元组,rank是当前三元组经过三维基数排序后的排名
            int rank = 0, c0 = -1, c1 = -1, c2 = -1;
            for (int i = 0; i < n02; i++) {
                // 如果当前三元组跟上一名三元组一摸一样,那么他俩应该拥有相同的名次,rank不++.反之排名应该递增,rank++
                if (c0 != nums[sa12[i]] || c1 != nums[sa12[i] + 1] || c2 != nums[sa12[i] + 2]) {
                    rank++;
                    // 记录当前三元组,在下一轮循环中作为上一名三元组参与比较
                    c0 = nums[sa12[i]];
                    c1 = nums[sa12[i] + 1];
                    c2 = nums[sa12[i] + 2];
                }

                // 1类:1开头的放到0位置,4开头的放到1位置..2类:2开头的放到0+n0位置,5开头的放到1+n0位置..这样把1类和2类分别划分到左右两边
                if (1 == sa12[i] % 3) {
                    s12[sa12[i] / 3] = rank;
                } else {
                    s12[sa12[i] / 3 + n0] = rank;
                }
            }

            /**
             * 如果基数排序无法严格将S12排序,那么递归生成S12的后缀排名数组
             */
            if (rank < n02) {
                // 如果一共有5个样本,结果最后的排名是第3,那么一定有相同的排名,也就是无法严格排序
                // 把S12递归求后缀排名数组,得到的结果就是严格排序后的,sa12[i]=k表示第i名是下标k开头的,i和k都在0和n02-1之间
                sa12 = skew(s12, n02, rank);
                // 把s12换成严格排序,去掉重复名次,但还是1类和2类分开.s12[i]=k表示下标i开头的排第k,排名从1开始,下标小于n0是1类,大于n0是2类
                // sa12[i]=k表示排第i的是k下标开头的,排名从0开始.
                for (int i = 0; i < n02; i++) {
                    s12[sa12[i]] = i + 1;
                }
            } else {
                for (int i = 0; i < n02; i++) {
                    // s12[i]=k表示下标i开头的排第k,排名从1开始,下标是转换后的下标,小于n0是1类,大于n0是2类
                    // sa12[i]=k表示排第i的是k下标开头的,排名从0开始.
                    sa12[s12[i] - 1] = i;
                }
            }

            /**
             * S12排好序后,通过一次基数排序将S0排好序
             */
            // s0记录0类下标,即[0,3,6,..].sa0[i]=k表示0类中排第i的是原始数据下标k开头的
            int[] s0 = new int[n0], sa0 = new int[n0];
            for (int i = 0, j = 0; i < n02; i++) {
                // 12类中排第i的是下标k开头的,而这个下标是经过转换的下标,小于n0是1类,大于n0是2类.
                // 这个下标是前面12类分居左右的时候,1类的下标除以3得到的(例如7/3=2),现在乘以3就是原始数据中该下标前面一个0类的下标(例如2*3=6)
                if (sa12[i] < n0) {
                    // 相当于先按照二元组(0类的值,12类中的排名)的第二维排序了.前置知识中讲过,0类三元组(0,1,2)可以转换成二元组(0, 12类中的排名)
                    s0[j++] = 3 * sa12[i];
                }
            }
            // 再按照二元组的第一维排序
            radixPass(nums, s0, 0, sa0, n0, K);

            /**
             * S0和S12 merge得到整个后缀排名数组
             */
            int[] sa = new int[n];
            // 为什么S12的指针从n0-n1开始?
            // 因为基数排序的时候,如果n0比n1大1,会把nums[n]算进去,nums[n]是补的0,一定会排在第0位,所以要把这个无效的排名跳过,所以n0比n1大1的时候从第1名开始,否则从第0名开始.
            for (int p = 0, t = n0 - n1, k = 0; k < n; k++) {
                int i = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;
                int j = sa0[p];
                if (sa12[t] < n0 ? leq(nums[i], s12[sa12[t] + n0], nums[j], s12[j / 3])
                        : leq(nums[i], nums[i + 1], s12[sa12[t] - n0 + 1], nums[j], nums[j + 1], s12[j / 3 + n0])) {
                    sa[k] = i;
                    t++;
                    if (t == n02) {
                        for (k++; p < n0; p++, k++) {
                            sa[k] = sa0[p];
                        }
                    }
                } else {
                    sa[k] = j;
                    p++;
                    if (p == n0) {
                        for (k++; t < n02; t++, k++) {
                            sa[k] = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;
                        }
                    }
                }
            }
            return sa;
        }


        /**
         * 在某一维度上基数排序
         *
         * @param nums   原始数据,整型数组或者字符串转换而来的整型数组
         * @param input  待排序的子串样本,用子串开头的下标表示,子串长度为3.例如给S12排序,那么input就是[1,2,4,5,...],逻辑上表示[ nums[1,2,3]子串, nums[2,3,4]子串, nums[4,5,6]子串, nums[5,6,7]子串, ... ]
         * @param offset 当前在样本的哪个维度上排序,例如offset=2表示按照第三维,也就是nums[1,2,3]子串按照3,nums[2,3,4]子串按照4,nums[4,5,6]子串按照6...
         * @param output 输出结果,output[0]=4表示样本在当前维度上排序,排第0名的是nums[4,5,6]子串
         * @param n 样本的个数
         * @param max 样本中所有维度的所有值中的最大值,用于确定桶的个数
         */
        private void radixPass(int[] nums, int[] input, int offset, int[] output, int n, int max) {
            // 创建桶,如果最大值为100,就要创建101个桶,分别为0号桶(弃而不用),1号桶...100号桶
            int[] bucket = new int[max + 1];

            // 入桶
            for (int i = 0; i < n; i++) {
                // input[i]是待排序子串的开头下标,加上offset才是当前要排序的维度的真实下标
                int curInput = input[i] + offset;
                // 原始数据中curInput位置是什么值,就在几号桶+1
                bucket[nums[curInput]]++;
            }

            // 这一步变换,是把i号桶里的值变成0到i-1号桶的累加和,这样i号桶的值就变成了名次(前面累计有0个,你就是第0名,前面累计有1个,你就是第1名)
            for (int i = 0, sum = 0; i < bucket.length; i++) {
                int t = bucket[i];
                bucket[i] = sum;
                sum += t;
            }

            // 出桶
            for (int i = 0; i < n; i++) {
                // 样本中用于排名的维度下标
                int curInput = input[i] + offset;
                // 根据样本当前维度的值,获取排名,桶里存的是前面桶的累加和,前面有几个当前样本就排第几.
                // 同一号桶里的多个样本(即在当前维度上每排出大小的多个样本),按照样本中的先后排序,所以桶里的值每次取完之后+1
                // 问:桶里记录的是前面的累加和,如果先取的后面的桶,前面的桶再++,不会出现重复的值吗?答:不会,因为如果累加和之前i号桶=1,说明i号桶里就一个样本,那么就算++了也不会第二次取他;如果i号桶>1,那么累加和后i+1号桶肯定比i号桶大不止1,所以i号桶++后不会跟后面重复.
                int curRank = bucket[nums[curInput]]++;
                // curRank表示排第几,作为下标,input[i]是待排序子串的开头下标
                output[curRank] = input[i];
            }
        }


        private boolean leq(int a1, int a2, int b1, int b2) {
            return a1 < b1 || (a1 == b1 && a2 <= b2);
        }

        private boolean leq(int a1, int a2, int a3, int b1, int b2, int b3) {
            return a1 < b1 || (a1 == b1 && leq(a2, a3, b2, b3));
        }


        /**
         * rank数组由sa数组加工而来
         * @return
         */
        private int[] rank() {
            int n = sa.length;
            int[] ans = new int[n];
            for (int i = 0; i < n; i++) {
                ans[sa[i]] = i;
            }
            return ans;
        }

        /**
         * height数组由sa数组和rank数组加工而来
         * @param s
         * @return
         */
        private int[] height(int[] s) {
            int n = s.length;
            int[] ans = new int[n];
            for (int i = 0, k = 0; i < n; ++i) {
                if (rank[i] != 0) {
                    if (k > 0) {
                        --k;
                    }
                    int j = sa[rank[i] - 1];
                    while (i + k < n && j + k < n && s[i + k] == s[j + k]) {
                        ++k;
                    }
                    ans[rank[i]] = k;
                }
            }
            return ans;
        }
    }


    // 为了测试
    public static int[] randomArray(int len, int maxValue) {
        int[] arr = new int[len];
        for (int i = 0; i < len; i++) {
            arr[i] = (int) (Math.random() * maxValue) + 1;
        }
        return arr;
    }

    // 为了测试
    public static void main(String[] args) {
//        int len = 100000;
//        int maxValue = 100;
//        long start = System.currentTimeMillis();
//        new DC3(randomArray(len, maxValue), maxValue);
//        long end = System.currentTimeMillis();
//        System.out.println("数据量 " + len + ", 运行时间 " + (end - start) + " ms");

        String str = "adccdccdeed";
        int[] arr = new int[str.length()];
        int i = 0;
        int max = 0;
        for (char c : str.toCharArray()) {
            arr[i++] = c;
            if (c > max) {
                max = c;
            }
        }

        DC3 dc3 = new DC3(arr, max);



    }
}
