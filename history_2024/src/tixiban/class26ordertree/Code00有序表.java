package tixiban.class26ordertree;

public class Code00有序表 {
    /**
     * 数据库最重要的就是索引,索引的目的就是为了查一条数据的时候不需要一行一行遍历O(logN),而是通过索引快速找到在第几行,然后直接去那行拿数据.
     * 索引都是用有序表实现的.
     *
     * 搜索二叉树:
     * 对于任意一个节点,比他大的一定在他右子树,比他小的一定在他左子树.
     * 这样可以根据二分的方式快速找到一个节点,构建的时候也比较简单.
     * 缺点:查询的性能依赖用户插入的顺序.如果用户依次插入1,2,3,4,5..那么搜索二叉树就会非常偏,查询起来就跟遍历一样,毫无性能可言.
     *
     * 左旋和右旋:
     * 用来让不平衡的搜索二叉树变得平衡的操作.
     * 说左旋右旋一定要说明在哪个头节点上左旋右旋,
     * 头节点左旋就是头节点往左边倒,右孩子上去,右孩子的左孩子成为头节点的右孩子,最终右孩子成为新的头,旧的头成为右孩子的左孩子.
     * 右旋刚好左右反过来.
     * 根据搜索二叉树的性质稍加推理,可以得出左旋右旋后依然满足搜索二叉树性质.
     *
     * 平衡搜索二叉树:
     * 有AVL树,SB树,红黑树等,
     * 不同的树有不同的平衡策略,但是平衡的基本操作都是左旋和右旋.
     * 三种树的时间复杂度都是O(logN).
     *
     */

    /**
     * 搜索二叉树怎么增删节点
     * 新增:
     * 从根节点开始遍历,如果新节点比当前节点大,往右走,否则往左走.直到走到null,把新节点挂在这.
     * 删除:
     * 1.删除节点无左无右:直接删除
     * 2.删除节点有左无右:左子树直接替代删除节点的位置
     * 3.删除节点有右无左:右子树直接替代删除节点的位置
     * 4.删除节点有左有右:找到删除节点右子树的最左节点替换删除节点,同时最左节点的右子树替代最左节点的位置.
     *   为什么右子树的最左节点?1.在右子树说明比左子树的都大.2.在最左说明比右子树的其他节点都小.因此这个节点放在头节点,左子树都比他小,右子树都比他大.
     *   同理,左子树的最右节点也满足条件.
     *
     *
     * 平衡搜索二叉树增删节点的方式跟搜索二叉树一样,只不过在可能影响平衡性的操作后面加了平衡策略.
     */

    /**
     * AVL树
     * 是一棵标准的搜索二叉树,增删节点的方式跟搜索二叉树一样,但是AVL树在增删操作后加了专属自己的平衡性补丁.
     *
     * 什么时候打补丁?平衡性被破坏的时候.
     * AVL的平衡性:
     * 任意一个节点,|左树高度 - 右树高度| <= 1
     *
     * 怎么看平衡性被破坏?4种违规类型.
     * LL,LR,RR,RL
     * LL违规:
     * LL方向上过长导致平衡性破坏. 即左子树过长,并且是左子树的左子树过长.
     * 举例:依次插入3,2,1
     * 解法:头节点3来一次右旋
     *
     * RR违规:
     * 同理,右子树过长,并且是右子树的右子树过长.
     * 举例:依次插入1,2,3
     * 解法:头节1点来一次左旋
     *
     * LR违规:
     * LR方向上过长导致平衡性破坏. 即左子树过长,并且具体是左子树的右子树长度过长导致不平衡.(如果左子树去掉右子树,只有左子树,他就会不违规)
     * 举例:依次插入3,1,2
     * 解法:1先左旋,3再右旋. (一句话:让LR上的孙子上来当根)
     *
     * RL违规:
     * 同理,右子树过长,并且具体是右子树的左子树过长导致不平衡.
     * 举例:依次插入1,3,2
     * 解法:3先右旋,1再左旋.(一句话:让RL上的孙子上来当根)
     *
     * 注意:
     * 如果既是LL违规,又是LR违规,这时一定要按照LL型处理,否则会翻车.case见截图.
     * 同理如果既是RR型违规又是RL型违规,一定要按照RR型处理.
     *
     * AVL平衡策略:
     * 插入:从插入节点开始,顺着父亲往上找每一个祖先,检查四种违规,命中就调整.
     * 删除:如果删除节点无右无左/有左无右/有右无左,那么从删除节点开始,顺着父亲往上找每一个祖先,检查四种违规,命中就调整,
     * 如果删除节点有左有右,拿右子树最左节点替换删除节点,那么从右子树最左节点的父亲开始往上检查.
     *
     *
     *
     */

    /**
     * 有序表和AVL树的关系
     * 有序表是接口/规范,AVL树是实现类.其他实现类还有SB树、红黑树、跳表、234树、B树、B+树等.
     * 具体实现的细节不同,但是有序表要求的功能,每棵树都实现了,有序表要求的性能(O(logN)),每棵树都满足.
     *
     */

    /**
     * 搜索二叉树查询<=x最近的那个
     *
     * 从根遍历,当前节点小于x就往右滑,沿途记录遇到的最后一个小于x的节点,直到当前节点大于x,返回记录的节点.
     */




    /**
     * SB树,SizeBalanceTree
     * 一、平衡标准:任何叔叔子树的节点数不少于侄子子树的节点数.画图:
     *       A
     *     /  \
     *    B    C
     *  / \   / \
     * D   E F   G
     * B是FG的叔叔,B为头的子树的节点数不小于F为头的子树的节点数、不小于G为头的子树的节点数.
     * 同理,C是DE的叔叔,C的节点数不小于D、E的节点数.
     * 如果一个节点没有叔叔节点,那么认为叔叔子树的节点数为0.
     *
     * 可以推出,A的左右两个子树,如果一个节点数多一个节点数少,那么差距不会超过两倍.
     * 复杂度依然是O(logN)
     *
     * SB数相较于AVL树,阉割了平衡性,平衡性敏感度低,目的是为了减少IO,不要那么频繁的调平衡.
     *
     *
     *       A
     *     /  \
     *    B    C
     *  / \   / \
     * D   E F   G
     *
     * 二、4种违规类型:
     * LL
     * 头节点左孩子的左子树的节点数,大于头节点右子树节点数.
     * 也就是左侄子节点数大于叔叔的节点数.
     * 例如上图中,D的节点数大于C的节点数.
     * LR
     * 上图中E的节点数大于C的节点数.
     * RR
     * 上图中G的节点数大于B的节点数.
     * RL
     * 上图中F的节点数大于B的节点数.
     *
     *       A
     *     /  \
     *    B    C
     *  / \   / \
     * D   E F   G
     *
     * 三、调平衡的方法:
     * LL
     * 1.跟AVL一样,对A进行一次右旋
     * 2.所有孩子发生变化的节点再递归调平衡(调整后的头节点和右孩子,即B和A).
     * 为什么要重复递归调平衡?因为孩子发生变化之后，不知道子树中是否有叔侄违规.
     * LR
     * 1.跟AVL一样,先B左旋,再A右旋
     * 2.所有孩子发生变化的节点再递归调平衡(调整后的头节点、左孩子、右孩子,即E、B、A).
     * RR
     * 1.对A进行一次左旋
     * 2.所有孩子发生变化的节点再递归调平衡(调整后的头节点和左孩子,即C和A).
     * RL
     * 1.跟AVL一样,先C右旋,再A左旋
     * 2.所有孩子发生变化的节点再递归调平衡(调整后的头节点、左孩子、右孩子,即F、C、A).
     *
     *
     * 四、SB树的平衡策略
     * 插入节点时调平衡,删除节点时不调平衡.(SB树的优势)
     *
     * 由于SB树调平衡是递归的,所以一旦插入一个节点,就会迅速调到平衡
     *
     * 问:删除不调平衡,那么有可能删成棒状结构,棒状结构不是会变慢吗?
     * 答:是会删成棒状结构,但是不会变慢,因为假如原本有2^64个节点,删成棒状最多也就64个,不会慢.
     * 复杂度O(logN)的N指的是达到的最大节点数.
     *
     */


    /**
     * 跳表
     *
     * 大致思路:在第一层找到小于等于最右的一个，跳到下一层，再往右找小于等于最右的一个，再跳到下一层。
     * 第l层的节点有0.5的概率决定是否在l+1层保留,所以,
     * 第logN+1层一定N个节点,第logN层大致N/2个节点,第logN-1层大致N/4个节点...第2层大致2个节点,第1层大致1个节点.
     * 上层每跨过一个节点，下层可能跨过多个节点。
     * 根据概率计算的复杂度为O(logN)
     *
     * 跳表图示:见 Picture03跳表图示.jpeg
     * 需要结合上面图示和下面图示一块理解.
     * 上面图示中,每一层中的2都是同一个节点,实线表示next指针,虚线表示同一节点跳到不同层的路径.
     * 下面图示中,每个节点有多个next指针表示不同层的next,head节点的key=null,head的层数和后面节点最大层数保持一致.
     * 所有节点在第0层一定都存在.
     * 顺着每层的next指针指下去一定是有序的.
     */


    /**
     * 红黑树
     * 不要被红黑树复杂的定义给吓到,只要记住红黑树也是一种平衡搜索二叉树,跟AVL树一样有自己的平衡策略,只不过这个平衡策略概念比较复杂.
     * 定义:
     * 1.任何一个节点不是红就是黑
     * 2.头节点为黑,叶节点为黑(红黑树认为null才是叶节点)
     * 3.任意两个红节点不相邻
     * 4.从任意节点出发往下走,每条子链上,黑节点数相等.
     * ...
     *
     * 总结红黑树的平衡策略:
     * 由4知,最长的链一定是红黑相间的,最短的链一定是全黑.
     * 因此,红黑树节点的任意子链之间,节点数相差不超过2倍
     *
     * 对比平衡策略:
     * AVL树:较高的子树和较低的子树,高度相差不超过1.
     * SB树:较大的子树和较小的子树,节点数相差不超过2倍.
     * 红黑树:较长的子链和较短的子链,节点数相差不超过2倍.
     *
     *
     * 记住
     * 什么是有序表(平衡搜索二叉树): 左旋+右旋+搜索二叉树的基本性质
     * 什么是红黑树: 一种有序表(平衡搜索二叉树),平衡策略为 较长的子链和较短的子链节点数相差不超过2倍.
     *
     * 作用:
     * 像SB树一样,模糊的平衡性,调平衡的频率低,减少IO消耗(对于应用在磁盘上的平衡搜索二叉树,减少IO消耗很重要).
     */

}