package tixiban.class1_13.笔记;

public class 图 {
    /**
     * 图的概念
     * 1、由点的集合和边的集合构成
     * 2、虽然存在有向图和无向图的概念，但是任何图都可以用有向图来表达（无向图的边就相当于两条双向的边）
     * 3、边上可能带有权值
     */

    /**
     * 图的表达
     * 1、邻接矩阵法。矩阵(i,j)的值表示节点i到节点j的距离（有权值的时候），或者是否可达（无权值的时候）。
     * 2、邻接表法。维护一个表，记录每个节点和他可达的其他节点，例如，无权值时{i:[a],j:[d,f]}，有权值时{i:[[a,1]],j:[[d,3],[f,2]]}。
     * 3、N*3矩阵法（刷题常给到的）。用3列的二维数组表示图的每条边，包括权值、出点和入点，例如[[4,i,j],[2,j,k],[1,i,l]]表示从i到j的边权值是4。
     * 4、除此之外还有众多方式
     */

    /**
     * 图的面试题如何搞定
     * 图的算法都不太难，只是coding的成本高，因为图的结构表达起来比较复杂。
     * 新手：
     * 1、先用自己最熟练的方式，实现图结构的表达。
     * 2、在自己熟悉的图结构上，实现所有常用的图算法作为模板。
     * 3、把面试题提供的图结构转化成自己熟悉的图结构，调用模板或改写即可。
     * 老手：
     * 给什么结构就用什么结构展开算法
     */

    /**
     * 图的宽度优先遍历
     * 利用队列实现
     * 1、从源节点开始，依次按照宽度进队列，然后弹出
     * 2、每弹出一个节点，把该节点[所有]没进过队列的相邻节点压入队列
     * 3、直到队列变空
     */

    /**
     * 图的深度优先遍历
     * 利用栈实现
     * 1、从源节点开始，依次按照深度进栈，然后弹出
     * 2、每弹出一个节点，把该节点[下一个]没有进过栈的相邻节点压入栈中
     * 3、直到栈变空
     */

    /**
     * 最小生成树
     * 最小生成树就是一个图的最小权重连通子图，一般针对无向图。
     * 给定一张无向图，如果在它的子图中，任意两个顶点都是互相连通，那么这个子图叫做生成树。
     * 当图中的路径有权重时，权重之和最小的生成树就是最小生成树
     *
     * 如果是一个森林，那么每个图求出最小生成树，最后就得到最小生成森林。
     */
}
