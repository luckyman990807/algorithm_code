package tixiban.class1_13.笔记;

public class 排序 {
    /**
     * 什么是排序算法的稳定性？
     * 就是相等的元素，排完序之后会不会改变相对次序，不改变，就稳定，改变，就不稳定。
     *
     * 稳定性的意义：
     * 例如商城的商品列表排序，假如用的排序算法是稳定的，那么先按价格排序，再按评分排序，结果最前面展示的一定是评分最高且在同样评分的商品中价格最低的。
     *
     * 哪些排序算法能做到稳定？
     * 1、选择排序不能，例如2221，第一轮选择一个最小的放在0位置，结果就是第一个2越过了中间的2跑到了最后面，改变相对次序了，不稳定。
     * 2、冒泡排序能，只要设置等于的时候不交换就可以。
     * 3、插入排序能，只要设置等于的时候不往前交换就可以。
     * 4、快排不能，荷兰国旗问题把某个数划到小于区，也可能会跨好几个数交换，和选择排序一个道理。
     * 5、堆排序不能，子节点和父节点在数组中不一定是挨着的，也会跨好几个数交换，和选择排序一个道理。
     * 6、桶排序可以，只要保证桶先进先出，因为进桶的顺序肯定和外面一样，只要出的顺序和进的顺序一样，那么出的顺序就和外面的一样。
     */

    /**
     * 排序算法总结
     *          时间复杂度       额外空间复杂度     稳定性
     * 选择      O(N^2)         O(1)            无
     * 冒泡      O(N^2)         O(1)            有
     * 插入      O(N^2)         O(1)            有
     *
     * 归并      O(N*logN)      O(N)            有
     * 快排      O(N*logN)      O(logN)         无
     * 堆排      O(N*logN)      O(1)            无
     *
     * 计数      O(N)           O(Max)          有
     * 基数      O(N)           O(N)            有
     *
     * 1、时间复杂度O(N*logN)，空间复杂度小于O(N)，且能做到稳定的排序算法，目前不存在。
     * 2、归并、快排、堆，追求速度选快排（实验证明快排的常数时间更短），追求额外空间小选堆，追求稳定性选归并。
     * 3、基于比较的排序，时间复杂度的极限是O(N*logN)。
     * 4、基于比较的排序，只要规定好两个样本怎么比大小，就可以直接复用。
     * 5、不基于比较的排序，对样本数据有严格要求，不易改写。
     */

    /**
     * 算法排序常见的坑
     *
     * 1、归并排序“内部缓存法”可以使空间复杂度优化到O(1)：会变得不再稳定。
     * 2、“原地归并排序”可以使空间复杂度优化到O(1)且能做到稳定性：会让时间复杂度变成O(N^2)。
     * 3、快排“01 stable sort”法可以做到稳定：会对样本数据有要求（既然有要求，那不如用桶排）。
     * 4、给定一个整型数组，要求把奇数放左边，偶数放右边，奇数之间保持原次序，偶数之间保持原次序，时间复杂度O(N)，额外空间复杂度O(1)：
     * 不存在这样的算法。奇数放左边，偶数放右边，和快排的<=放左边，>放右边一样，是一个0/1partition过程，如果有这么一个算法可以实现0/1partition的同时做到稳定，那么写快排的人为什么不用？
     */

    /**
     * 工程上对排序算法的改进
     *
     * 1、针对稳定性的改进
     * Java中Arrays.sort()会判断数组元素的类型，如果是基础类型，就执行随机快排，如果是非基础类型，就执行归并排序。
     * 为什么：基础类型不需要稳定性，因为值相等就是相等，所以优先选择更快的快排。非基础类型用户有可能需要稳定性，所以优先选择具有稳定性的归并排序。
     *
     * 2、针对常数项的改进
     * Java中Arrays.sort()在数据量大的时候，执行随机快排，数据量小于60的时候执行插入排序。
     * 为什么：插入排序虽然在N趋于无穷的时候，时间复杂度是O(N^2)，但是因为代码很简单，常数项小，所以数据量小的时候更占优势。60是实验出来的。
     */
}
