package tixiban.class1_13.笔记;

public class 二叉树 {
    /**
     * 先序遍历，中序遍历，后序遍历
     * public void f(Node tree){
     *     if(tree == null){
     *         return;
     *     }
     *     // 先序遍历
     *     f(tree.left);
     *     // 中序遍历
     *     f(tree.right);
     *     // 后序遍历
     * }
     *
     * 二叉树的递归序：
     * 用递归的方式遍历二叉树时，每个节点都会回到自己3次：1、遍历自己的时候(遍历左右子树之前)，2、遍历左子树回来的时候，3、遍历右子树回来的时候
     *
     *
     * 问题：给定一个二叉树，先序遍历的结果是[A],X,[B]，后序遍历的结果是[C],X,[D]，如何证明A∩D就等于X的全部祖先节点？
     *
     * 首先，对于X来说，所有节点可分为4类：
     * 1、祖先节点（父节点、爷爷节点等）
     * 2、后代节点（子节点、孙子节点等）
     * 3、某祖先的右子树（右兄弟节点整个子树、右叔叔节点整个子树等）
     * 4、某祖先的左子树（左兄弟节点整个子树、左叔叔节点整个子树等）
     *
     * ∵先序遍历，∴X的祖先必然都在A中，X的后代必然都在B中。因为后序遍历，所以X的后代必然都在C中，X的祖先必然都在D中。
     * 也就是A、D都包含祖先节点，且都不包含后代节点。下一步就是证明A∩D中没有祖先左子树和祖先右子树。
     *
     * ∵对于祖先们来说，先序遍历时某祖先右子树一定在X后边，后序遍历时某祖先的左子树一定在X前边
     *
     * 因此先序遍历的结果可以写成：[X的祖先们,祖先们的左子树们],X,[X的后代们,祖先们的右子树们]，
     * 后序遍历的结果可以写成：[X的后代们,祖先们的左子树们],X,[X的祖先们,祖先们的右子树们]，
     * 所以A∩D=[X的祖先们]
     */

    /**
     * 二叉树递归套路
     *
     * 任何问题，假设一个节点可以从左右孩子要任何信息，
     * 然后罗列所有可能性，求所有可能性涉及到的信息的全集，就是要从左右孩子获取的信息，
     * 然后组织自己节点的信息。
     *
     * 判空的时候，好赋值就赋上，不好赋值（例如空节点无法定义最大值最小值）就返回null
     */
}
