package shuatiban;

/**
 * 一个环形链表，有n个节点，编号从1到n，从1号节点开始循环，从1开始报数，规定每次报到m的人出局，下一个人重新从1开始报数。求这n个节点中最后留下来的一个是谁
 *
 * 思路：
 * 普通解：完全模拟环形链表循环报数，时间复杂度n*m，因为要出局n-1个人，每出局一个人都要报m次。
 * 最优解：依赖两个公式：1，由出局之后的新编号推出局之前的旧编号；2，由报数推编号。
 * 1，由出局之后的新编号推出局之前的旧编号。
 * 假设每次出局之后剩下的人重新编号，例如
 * 旧编号：1，2，3，4，5，共5个人，假设3出局，那么剩下的人从下一个开始重新编号：
 * 新编号：3，4，x，1，2
 * 这里要根据一个人的新编号推这个人的旧编号。
 * 为什么要推这个？因为最后幸存者的新编号（即最后一次出局之后剩下的新编号）一定是1，如果能根据新编号推旧编号，那么一直往前推一直往前推，总会推出这个幸存者最初的编号，就是答案。
 * 把上面的例子画成函数坐标，自变量是新编号，因变量是旧编号，得到一个两截的剃刀函数，看到剃刀函数就要往y=x%n这个函数上凑，上面的那段剃刀往下延伸到和下面那段一样低，下面那段剃刀往上延伸到和上面一样高，
 * 再根据「上加下减，左加右减」的原则，分析得到由新编号推旧编号的函数是 y = (x + i - 1) % n + 1，n是本次出局之前的人数，i是报数报到m就出局的那个人在n个人中的编号
 * 2，由报数推编号。
 * 即我报的数是m，那我在n个人中的编号是多少？例如
 * 编号：1，2，3，4，5，共5个人，假设报到8出局，
 * 报号：1，2，3，4，5，
 *      6，7，8，
 * 把上面的例子画成函数坐标，自变量是报号，因变量是编号，得到一个剃刀函数，看到剃刀函数就往y=x%n这个函数上凑，
 * 根据「左加右减，上加下减」的原则，分析得到由报号推编号的函数是 y = (x - 1) % n + 1，n是当前的人数
 *
 * 把公式2带入到公式1中，把出局编号i替换成报号（出局的人报的号一定是m）得到由新编号推旧编号的函数是 y = [x + (m - 1) % n] % n + 1
 *
 *
 *
 */
public class Code085约瑟夫环问题 {
    public static int iceBreakingGame(int n, int m) {
        // 幸存者最后一次出局后的编号是1
        int ans = 1;
        // 最后一次出局前的人数是2
        int count = 2;
        while (count <= n) {
            // 由出局后的编号，和出局前的人数，推出局前的编号
            ans = (ans + (m - 1) % count) % count + 1;
            // 往前推了一步，人数++，直到人数加到n，由第一次出局前的人数n，求出局前的编号
            count++;
        }
        // 因为leetcode上编号是从0开始的，而我们的公式编号是从1开始的，因此要减1
        return ans - 1;
    }
}
