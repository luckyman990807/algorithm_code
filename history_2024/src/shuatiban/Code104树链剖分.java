package shuatiban;

/**
 * 树链剖分专题
 * 给定数组father，大小为N，表示一共有N个节点
 * father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
 * 给定数组values，大小为N，values[i]=v表示节点i的权值是v
 * 实现如下4个方法，保证4个方法都很快！
 * 1)让某个子树所有节点值加上v，入参：int head, int v
 * 2)查询某个子树所有节点值的累加和，入参：int head
 * 3)在树上从a到b的整条链上所有加上v，入参：int a, int b, int v
 * 4)查询在树上从a到b的整条链上所有节点值的累加和，入参：int a, int b
 *
 * 思路：一看到某个范围上都加某个值、某个范围上求累加和，就想到线段树。只不过正常线段树的范围描述的是数组的下标区间，这道题难点就是怎么把“子树”转换成数组的“区间”
 *
 * 几个概念：
 * 重儿子：所有子树中节点数最多的那个。如果有多个子树的节点数相等，那么从中任意取一个
 * 重链：从根节点或者轻儿子出发，沿着重儿子往下走，形成的链。如果这个节点是叶子节点，那么他自己就组成一条重链。
 * 重链的头：重链上的每个节点都记录所在重链的头，目的是快速跳到根节点（通过重链找头，再通过轻链找父，再通过重链找头，再通过轻链找父……复杂度取决于重链的个数，O(logN)级别，具体证明略）
 * dfs序：按照先走重链的顺序遍历这棵树，并给节点重新编号。例如：
 *     4
 *    / \
 *   2   5
 *  /   / \
 * 6   3   7
 *        /
 *       1
 * 按照先走重链的数序，这棵树重新编号后（编号从1开始）：
 *     1
 *    / \
 *   6   2
 *  /   / \
 * 7   5   3
 *        /
 *       4
 * dfs序的特点：一颗子树上的编号是一个连续区间，一条重链上的编号也是一个连续区间（把对子树的操作转换成对区间的操作，靠到线段树上了；把对重链的操作也靠到线段树上了，轻链还没靠）
 *
 */
public class Code104树链剖分 {
}
