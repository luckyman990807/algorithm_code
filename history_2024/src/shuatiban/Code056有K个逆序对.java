package shuatiban;

/**
 * https://leetcode.com/problems/k-inverse-pairs-array/
 *
 * 逆序对的定义如下：对于数组 nums 的第 i 个和第 j 个元素，如果满足 0 <= i < j < nums.length 且 nums[i] > nums[j]，则其为一个逆序对；否则不是。
 * 给你两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个 逆序对 的不同的数组的个数。由于答案可能很大，只需要返回对 109 + 7 取余的结果。
 *
 * 提示：
 * 1 <= n <= 1000
 * 0 <= k <= 1000
 *
 * 思路：
 * 根据数据量猜解法，n*k=10^6，差不多到10^8了，所以猜测解法的复杂度是O(n*k)，一张n*k的dp表。
 * 那么该赋予这张dp表什么含义呢？谜底就在谜面上，dp[i][j]=x就表示从1到i的数字排列组合，恰好有j个逆序对的组合有x种。
 * 这是一个样本对应模型，样本对应模型的解法一般都围绕最后一个元素。
 */
public class Code056有K个逆序对 {
    /**
     * 从1到n的数字排列组合，求一共有k个逆序对的组合有几种？
     */
    public static int kInversePairs(int n, int k) {
        int mod = 1000000007;
        int[][] dp = new int[n + 1][k + 1];
        // dp[n][0]都=1，因为不论几个数，想要形成0个逆序对，只有升序排列一种方法
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        // dp[0][k]都=0，因为0个数想要形成k个逆序对是不可能的，有0种方法
        for (int j = 1; j <= k; j++) {
            dp[0][j] = 0;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                // 分析，举个例子dp[5][3]怎么求？也就是1到5排列组合，要求有3个逆序对，要依赖哪些信息？猜测依赖1到4的结果，也就是dp[4][x]
                // 如果1到4能产生3个逆序对，那么把5放在最后位置，不就成了1到5产生3个逆序对了吗？这种情况对应的方法数就是dp[4][3]
                // 继续分析，如果把5放在倒数第二个位置abc5d（abcd表示1到4的任意排列组合），那么5跟d会产生一个逆序对，就要求剩下的abcd之间有2个逆序对，也就是1到4有2个逆序对，有几种组合呢？dp[4][2]
                // 同理，5在倒数第三个位置ab5cd，5跟cd各产生一个逆序对，要求1到4有1个逆序对，有几种组合呢？dp[4][1]
                // 直到把5放在第一个位置5abcd，5和abcd之间各产生一个逆序对，这就有4个了，但是只要求3个，所以5不能放在最前面。
                // 综上，dp[5][3]=dp[4][3]+dp[4][2]+dp[4][1]+dp[4][0]

                // 看起来要遍历才能求出一个格子？根据数据量分析是不可能的，再遍历就超时了，所以分析斜率优化：
                // dp[5][3]=dp[4][3]+dp[4][2]+dp[4][1]+dp[4][0]
                // dp[5][4]=dp[4][4]+dp[4][3]+dp[4][2]+dp[4][1]+dp[4][0]
                // 1式带入2式得dp[5][4]=dp[4][4]+dp[5][3]，依赖2个格子即可，也就是
                // dp[i][j]=dp[i-1][j]+dp[i][j-1]

                // 上面求dp[i][j]的方法是i>j的情况，i<=j的情况略有不同，
                // 例如1到5要求7个逆序对，有几种方法？
                // 5放在最后：abcd5，5产生0个，要求1到4有7个，有几种方法？dp[4][7]
                // 一直到5放在第一个：5abcd，5和他们产生4个，要求1到4有3个，有几种方法？dp[4][3]
                // dp[5][7]=dp[4][7]+dp[4][6]+dp[4][5]+dp[4][4]+dp[4][3]
                // 同理分析可知dp[5][8]=dp[4][8]+dp[4][7]+dp[4][6]+dp[4][5]+dp[4][4]
                // 1式带入2式得dp[5][8]=dp[4][8]+dp[5][7]-dp[4][3]，依赖3个格子即可，也就是
                // dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-i]

                // 这里取模是因为怕结果很大溢出，所以题目要求把结果模一个数之后返回
                // 但是我们a-b的两个数都是模完之后的，可能原本a>b，模完之后a<b了，直接(a-b)%mod会影响最终结果，所以(a-b+mod)%mod先加上一个模再取模，保证是正数。
                if (i > j) {
                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;
                } else {
                    /** 这里没搞明白为啥非得里面相加的结果也要模一下 */
                    dp[i][j] = ((dp[i - 1][j] + dp[i][j - 1]) % mod - dp[i - 1][j - i] + mod) % mod;
                }
            }
        }
        return dp[n][k];
    }
}
