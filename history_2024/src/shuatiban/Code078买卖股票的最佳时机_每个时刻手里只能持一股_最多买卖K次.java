package shuatiban;

/**
 * https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/
 * 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。
 * 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 */
public class Code078买卖股票的最佳时机_每个时刻手里只能持一股_最多买卖K次 {
    /**
     * 分析dp[8][4]的位置依赖，也就是从0到8时刻买卖4次，获得的最大收益
     * 可能性1、8时刻不参与交易，0到8买卖4次的收益等于0到7买卖4次的收益，即dp[8][4]=dp[7][4]，这个没法优化，必须要求一下
     * 可能性2、8时刻参与交易，那么8时刻一定是最后一次交易的卖出时刻，按照最后一次交易的买入时刻又分为以下情况：
     * 1）最后一次交易8时刻买8时刻卖，收益=[8]-[8]，再加上前3次交易一定发生在0到8时刻，也就是dp[8][3]，整体0到8时刻买卖4次的最大收益=[8]-[8]+dp[8][3]
     * 2）最后一次交易7时刻买8时刻卖，整体收益=[8]-[7]+dp[7][3]
     * 3）最后一次交易6时刻买8时刻卖，整体收益=[8]-[6]+dp[6][3]
     * ...
     * m）最后一次交易0时刻买8时刻卖，整体收益=[8]-[0]+dp[0][3]
     * 可能性2的结果就是这m种情况取最大值。
     * 最后可能性1和可能性2取最大值。
     */
    public int maxProfitDpEnum(int k, int[] prices) {
        // dp[i][j]=k表示，从0到i时刻，必须买卖j次，能获得的最大收益
        int[][] dp = new int[prices.length][k + 1];
        // dp[0][j]=0，因为从0到0也就是只在0时刻，0时刻买然后0时刻卖，无论买卖几次，收益都是0
        // dp[i][0]=0，因为买卖0次不会有任何收益
        for (int i = 1; i < prices.length; i++) {
            for (int j = 1; j <= k; j++) {
                // 可能性1、i时刻不参与交易，那么dp[i][j]=dp[i-1][j]，即从0到i-1时刻，必须买卖j次，能获得的最大收益
                dp[i][j] = dp[i - 1][j];
                // 可能性2、i时刻参与交易，那么i时刻一定是卖出时间。而买入时间可能是i，i-1，i-2...取所有情况的最大值
                for (int h = 0; h <= i; h++) {
                    dp[i][j] = Math.max(dp[i][j], prices[i] - prices[h] + dp[h][j - 1]);
                }
            }
        }
        return dp[prices.length - 1][k];
    }

    /**
     * 动态规划中出现了枚举可能性，就尝试斜率优化，也就是分析格子的位置依赖，把枚举行为优化成有限个位置的依赖。
     * 上一种方法分析了dp[8][4]的依赖关系，即：
     * 可能性1，dp[7][4]
     * 可能性2，
     * max{ 1）[8]-[8]+dp[8][3]
     * 2）[8]-[7]+dp[7][3]
     * 3）[8]-[6]+dp[6][3]
     * 4）[8]-[5]+dp[5][3]
     * ...
     * m）[8]-[0]+dp[0][3] }
     *
     * 同样的思路分析dp[7][4]的依赖关系，得到：
     * 可能性1，dp[6][4]
     * 可能性2，
     * max{ 1）[7]-[7]+dp[7][3]
     * 2）[7]-[6]+dp[6][3]
     * 3）[7]-[5]+dp[5][3]
     * 4）[7]-[4]+dp[4][3]
     * ...
     * m）[7]-[0]+dp[0][3] }
     *
     * 分析能否用dp[7][4]加速dp[8][4]可能性2的枚举？发现最大的卡点是dp[8][4]可能性2枚举的首项都是[8]，而dp[7][4]枚举的首项都是[7]，无法把dp[7][4]直接带入dp[8][4]。
     * 因此我们把首项提取出来：
     * dp[8][4]枚举：
     * max{
     * dp[8][3]-[8]
     * dp[7][3]-[7]
     * dp[6][3]-[6]
     * dp[5][3]-[5]
     * ...
     * dp[0][3]-[0]
     * } + [8]
     *
     * dp[7][4]枚举：
     * max{
     * dp[7][3]-[7]
     * dp[6][3]-[6]
     * dp[5][3]-[5]
     * ...
     * dp[0][3]-[0]
     * } + [7]
     *
     * 把dp[7][4]枚举带入dp[8][4]枚举可得：
     * dp[8][4]枚举：
     * max{
     * dp[8][3]-[8]
     * dp[7][4]枚举max - [7]
     * } + [8]
     * 这就把枚举优化成了对两个格子的依赖。
     */
    public int maxProfit(int k, int[] prices) {
        // 过滤，如果最大买卖次数k大于等于n/2，就相当于没有次数限制，直接把所有爬坡的收益全算一遍。因为最多也就有n/2个爬坡。
        if (k >= prices.length >> 1) {
            int ans = 0;
            for (int i = 1; i < prices.length; i++) {
                ans += Math.max(prices[i - 1] - prices[i], 0);
            }
        }
        // dp[i][j]=k表示，从0到i时刻，必须买卖j次，能获得的最大收益
        // dp[0][j]=0，因为从0到0也就是只在0时刻，0时刻买然后0时刻卖，无论买卖几次，收益都是0
        // dp[i][0]=0，因为买卖0次不会有任何收益
        int[][] dp = new int[prices.length][k + 1];

        int preMax;
        for (int j = 1; j <= k; j++) {
            // 单独抽取出来dp[i-1][j]中可以带入dp[i][j]的部分，把dp[i][j]的枚举简化成两个位置的依赖
            preMax = dp[0][j - 1] - prices[0];
            for (int i = 1; i < prices.length; i++) {
                // 可能性1、i时刻不参与交易，那么dp[i][j]=dp[i-1][j]，即从0到i-1时刻，必须买卖j次，能获得的最大收益
                dp[i][j] = dp[i - 1][j];
                // 可能性2、i时刻参与交易，那么i时刻一定是卖出时间。而买入时间可能是i，i-1，i-2...取所有情况的最大值
                dp[i][j] = Math.max(dp[i][j], Math.max(dp[i][j - 1] - prices[i], preMax) + prices[i]);
                // 更新抽取部分，用于带入优化dp[i+1][j]的枚举
                preMax = Math.max(preMax, dp[i][j - 1] - prices[i]);
            }
        }
        return dp[prices.length - 1][k];
    }
}
